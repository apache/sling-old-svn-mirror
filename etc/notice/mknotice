#!/bin/bash
# ---------------------------------------------------------------------------
# Generate NOTICE files for ASF projects based on Maven
# dependencies.
# ---------------------------------------------------------------------------
# Runs mvn dependency:resolve, filters the output to get the list of non-ASF 
# dependencies, and uses the names in this list to concatenate a series of 
# notice fragment files found under this directory.
#
# To generate a NOTICE file, run this script from the directory that contains 
# the module's pom.xml file. Or use something like this to run it on a whole
# project tree:
#
#	export SCRIPT=/fullpath/of/mknotice
#  	find . -name pom.xml | grep -v target | while read pom 
#	do 
#		cd $(dirname $pom) 
#		$SCRIPT > NOTICE
#		cd -
#	done
#
# This script must be in the same directory as the noticemap.txt, which maps 
# dependency names to the names of NOTICE fragment files.
#
# Those NOTICE fragment files are found under the "notices" directory that 
# must also be found in the directory that contains this script.
# ---------------------------------------------------------------------------
# Dependencies are mapped to NOTICE fragments as follows (example):
#
#	1) mvn dependency:resolve output contains 
#		[INFO]    org.mortbay.jetty:jetty:jar:6.1.6 (scope = compile)
#
#	2) Reduce this to "org.mortbay.jetty:jetty"
#
#	3) Look for that string in noticemap.txt:
#		org.mortbay.jetty:jetty=jetty.txt
#	
#	4) If not found, fatal error. If ends with =NO_NOTICE, ignore this 
#		dependency.
#
#	5) In this case, =jetty.txt means "use the notices/jetty.txt fragment
#		for this dependency.
# 
# ---------------------------------------------------------------------------
#

ME=$(basename $0)
MYDIR=$(dirname $0)
NOTICES=$MYDIR/notices
NOTICEMAP=$MYDIR/noticemap.txt
GLOBAL_PREFIX=$NOTICES/prefix.txt
PROJECT_NAME=""
MVN_OPT="-o"
LOCAL_NOTICE="module.notice.txt"

fatal() {
  echo ""
  echo "$0 ($PWD): FATAL ERROR:" $* >&2
  exit 1
}

set_project_name() {
  PROJECT_NAME=$( \
	  mvn $MVN_OPT validate \
	  | grep "INFO.*Building" | head -1 \
	  | sed 's/.*INFO.*Building//' \
	  | sed 's/Sling/Apache Sling/g'
	)	  
}

add_notice() {
  NFILE=$NOTICES/$1.notice.txt
  [[ -f $NFILE ]] || fatal "$NFILE not found"
}

# Collect dependencies of current module, and filter their names
# so that they can be used as input to map_deps
collect_deps() {
  NO_NOTICE_FILTER="org.apache|commons-"
  GOAL="dependency:resolve"
  
  ( mvn $MVN_OPT $GOAL || fatal "mvn $MVN_OPT $GOAL failed" ) \
  | grep '\[INFO\].*:.*:.*:.*' \
  | grep -v ":test$" \
  | grep -v 'Finished at:' \
  | egrep -v "$NO_NOTICE_FILTER" | awk -F' ' '{ print $2 }' \
  | cut -d':' -f1-2
  [[ -f $LOCAL_NOTICE ]] && egrep '^[^#]' $LOCAL_NOTICE
}

# Map a list of dependencies to their notice files
# Input is like
#	org.eclipse.equinox.http:servlet
#	org.slf4j:jcl104-over-slf4j
#	org.slf4j:slf4j-api
#	org.slf4j:slf4j-log4j12
#
# and output is built from the NOTICEMAP:
#	equinox.txt
#	slf4j.txt
map_deps() {
    [[ -f $NOTICEMAP ]] || fatal "$NOTICEMAP not found"
	while read dep
	do
		mapped=$(grep "^${dep}=" $NOTICEMAP)
		[[ -n "$mapped" ]] || fatal "No mapping found for '$dep' in $NOTICEMAP"
		echo "$mapped"
	done | cut -d= -f2
}

# collect dependencies, map them to their notice
# files and concatenate those
generate_notice() {
	set_project_name
	[[ -n "$PROJECT_NAME" ]] || fatal "Project name not found"
	echo $PROJECT_NAME 
	echo "" 
	cat $GLOBAL_PREFIX || fatal "prefix output failed"
	( 
		collect_deps | map_deps | sort -u | while read notice
		do
		  if [[ "$notice" = NO_NOTICE ]]
		  then
		  	continue
		  fi
		  notice=$NOTICES/$notice
		  [[ -f $notice ]] || fatal "Notice file $notice not found"
		  if [[ "$MKNOTICE_DEBUG" -eq 1 ]]
		  then
		    echo "[DEBUG] $ME: including notice file $notice"
		  fi
		  cat $notice
		  echo ""
		  echo ""
		done
	) | egrep '^($|[^#])' | cat -s
}

generate_notice
